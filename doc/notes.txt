1/16 (TUES)

No need to combine operator types into one class, i.e. operator tokens become <operator, '+'>; causes problems later when parsing and checking precedence

dynamic dipatch?

Parts of speech 
Start, terminals, nonterninals, productions

Scanner only recognizes terminals; nonterminals are things like expressions, or sets of terminals

char classes - letter, number, symbol

Outside of main switch (not just in the default case or 0-9 cases:
    if letter - parse identifier or reserved word
    if number - parse num literal
    if symbol - go into char switch

Scanner - just get the next token - don't return all at once (other than for debug)

Go back in and make sure newlines always increment the line counter - carry along with the token so it can be identified at later stages. Also check for windows line endings (\r\n). Also \r should be in the whitespace category




1/18 (THURS)

Deterministic Finite Automata (DFA)


Dealing with scope:

Linked list of all symbols as they're added. When there's a new lexical level, place a marker on the chain indicating the new scope level. On the end of a scope, back up the chain (double linked list) until hitting the new scope level marker.

Declare multiple symbol tables; one for each scope


Lexer should throw an error when there's an illegal char; should not throw for comments
Error flags
Error reporting 


Digits can have underscores


Possibility - extend char classes; instead of [ch] -> token, have chars mapped to structs which have token type, isvalidchar, isvalidinstring, isvaliddigit


Presentation topics:

flex parser generator
LALR/bison parser generator
antlr LL(k)
JIT Translation
Garbage collection maybe?



Do LLVM rather than C





1/22 (MON)

Some questions

Is string a valid type_mark?
Seems to be referenced as a usable type in the language spec but it's not in the type_mark bnf


What is the default value of a newly declared var 
    (test1.src declares an integer but never sets it)
Should that integer be set to 0 initially?



1/23 (TUES)



