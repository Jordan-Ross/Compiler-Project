1/16 (TUES)

No need to combine operator types into one class, i.e. operator tokens become <operator, '+'>; causes problems later when parsing and checking precedence

dynamic dipatch?

Parts of speech 
Start, terminals, nonterninals, productions

Scanner only recognizes terminals; nonterminals are things like expressions, or sets of terminals

char classes - letter, number, symbol

Outside of main switch (not just in the default case or 0-9 cases:
    if letter - parse identifier or reserved word
    if number - parse num literal
    if symbol - go into char switch

Scanner - just get the next token - don't return all at once (other than for debug)

Go back in and make sure newlines always increment the line counter - carry along with the token so it can be identified at later stages. Also check for windows line endings (\r\n). Also \r should be in the whitespace category


================================================================================

1/18 (THURS)

Deterministic Finite Automata (DFA)


Dealing with scope:

Linked list of all symbols as they're added. When there's a new lexical level, place a marker on the chain indicating the new scope level. On the end of a scope, back up the chain (double linked list) until hitting the new scope level marker.

Declare multiple symbol tables; one for each scope


Lexer should throw an error when there's an illegal char; should not throw for comments
Error flags
Error reporting 


Digits can have underscores


Possibility - extend char classes; instead of [ch] -> token, have chars mapped to structs which have token type, isvalidchar, isvalidinstring, isvaliddigit


Presentation topics:

flex parser generator
LALR/bison parser generator
antlr LL(k)
JIT Translation
Garbage collection maybe?



Do LLVM rather than C



================================================================================

1/22 (MON)

Some questions

Is string a valid type_mark?
Seems to be referenced as a usable type in the language spec but it's not in the type_mark bnf


What is the default value of a newly declared var 
    (test1.src declares an integer but never sets it)
Should that integer be set to 0 initially?


================================================================================

1/23 (TUES)


Dynamic linking

backend is NPC
NPC (NP Complete)


-O flags in gcc (Error levels)
-Os should make program smaller
For my compiler, it adds 2k to the program size. Why?

Dynamic cast?


================================================================================

1/25 (THURS)


Student presentations:

Next Thurs
LLVM?

LLVM language

In memory format - Tie in to LLVM API for syntax tree 

LLVM Optimization

Flex - lexical analyzer generator (one student)




Intro to parsing

Sequence of tokens -> (abstract) syntax tree

Check the syntax (structure) of the program

Can't be specified with FSA or regex;
languages have non-regular constructs
    -Nesting
    -Recursion


BNF usually refers to EBNF (Extended BNF)

Syntax      - The sequence of tokens work together (parsing)
Semantics   - The types match and make sense (type checking)


Derivations
rightmost   - rightmost non-terminal is replaced at each step
leftmost    - leftmost ""

E =*> 3 + 8 - 2
E goes to the statement through derivations

Precedence in expressions is done with expr, term, factor 
    expr is composed of lowest precedence operators (+-) and terms
    terms are composed of higher precedence operators (*/) and factors
    factors - numbers/ids
Same parse tree under both leftmost/rightmost derivations



LLVM In-memory format



Symbol table in parser

main symbol table --- f1() symbol table --- f2() symbol table

while in f2, it checks f2 symbol table first but can check the ones up the stack as well



In scanner, simplify adding operators; the Token struct would be like: (TokenType::ADDING, specific token = + | -)


================================================================================

1/30 (TUES)

Parsing (Slides pt 2)

Top down parsing


One pass compiler (no intermediate form)
Don't try to solve future problems yet, just do the parser.


Need to recognize EOF


Parser should know what to expect next based on the structure of the language. 
e.g. 
IDENTIFIER := 
parser should expect an rvalue that can be assigned to an identifier, that is an expr or other valid rvalue

LL(1) - only look at single token
LL(k) - bad; grows exponentially


Top down parsers can only handle right recursive grammars
Our parser is left recursive, so we need a bottom up parser

Eliminate left recursion - left factoring

expr'() {
    token = scan()
    if token.tt == adding {
        token = scan()
        term()
        expr'()
    }
}

expr() {
    term()
    expr'()
}


Don't worry about errors yet


Given A -> a | b
a intersection b must be empty set
That is, a cannot contain the same symbols as b. 
First token of A must uniquely identify that it's type a or b.


empty string in FIRST(a) - first token of a



================================================================================

QUESTION:

When to get first token of a group? before entering that group or while in that group
e.g. when looking at program_body, a token is needed before entering declaration or statement 
    because it needs to check for program begin/end. 
    This means that while in statement/declaration, the first token of that block
    may already be consumed. 
    We can't put back and we can't peek tokens, so how do we deal with this?

Possible solution: assume that the group above on the call stack will 
    get the first token of the current group


What about optional things? 
    For a variable decl, there is optionally a [n] after for defining arrays.
    This may or may not be there, and there may just be a semicolon 
        or in|out|inout if it's a parameter. 
    But, the semicolon belongs in 

        <program_body> | <procedure_body> 
        
    and not <variable_declaration> or even <declaration>.

    If we let <variable_declaration> consume the semicolon, we need to:
        - Make sure all other declarations consume the optional semicolon
            - That is, <proc_declaration> has to consume one more token, even
                though that should always be a semicolon
        - Make sure every other usage of <variable_declaration> knows that it will
            consume an extra token 
            - That is, <parameter> needs to know that a call to 
                <variable_declaration> consumes the in|out|inout following it.




How exactly do in|out|inout work?


What is a declared variable set to by default?



================================================================================
2/1 (THURS)

Symbol table usage
Lexer   -   Looks up symbols 
Parser  -   Holds scope / type information 


Non constant lower/upper bound for arrays
Array can be indexed starting at lower bound (instead of 0 or 1)

Get conditional based parsing like arrays and else


Email him the test programs that need correcting 
-done

Strings are a type



Incorrect programs (don't contain lower bounds)

test1
test1b



Should we unconditionally call functions 
    or determine whether we should enter them beforehand?
i.e. for something like statement, should we check whether 
    it's an if/for/whatever or just call if();for();



================================================================================
2/5 (MON)

Working on the parser; realized that LL(1) requires 1 token of lookahead, which
    is something I was trying to avoid. LL(1) parsers do require that one token
    can be checked without being read/consumed. 
    
We're doing a recursive descent parser though, which doesn't appear to require
    lookahead. It seems to be enough to just accept/expect symbols and call 
    nextsym (look at the wiki for recursive descent parsing).

........................................

GCC recursive descent parser ideas:

/* Retrieve the code of the current token; if there is no current token, 
   get the next one from the lexer.  */
token()

/* Retrieve the value of the current token (if any) and mark it consumed.
   The next call to token() will get another token from the lexer.  */
advance()

/* If the next token does not have code T, report a parse error; otherwise
   return the token's value.  */
require(int t)



TODO: Improve error handling. it's bad.



program body and proc body are identical, other than the final RS word


================================================================================
2/6 (TUES)

Proc call or var assignment
we can't tell which one in an LL(1) parser

stmnt -> assign_stmnt | proc_call
First(A) union First(B) != empty set

Fix:

stmnts -> 
    identifier tail
tail -> 
    if tok.tt = ":="
        assignment()
    else
        proc_call()
        


LLVM Presentation
Assembler 
    Show assembler
    Show copmilation
IR
    Instantiating an IR tree 



Optimization (not us)



We can use slides from other universities
Wikipedia is a valid source



Symbol table
Linked list of parameters
struct {
    id: char*
    type: TokenType
}

................................................................................

Q: Should lower/upper bounds be numbers or integers only?
bounds are ints (from doc)

Better Q: Should there even be integer/float literals or just "number" literals
probably should keep both; would save work later



================================================================================
2/7 (WED)

Issue with assignment statement: doesn't support indexed var assignment:
var[0] := 1 

Solution: check for L_PAREN and go into proc_call from identifier_statement
Otherwise, go into assignment statement.



All 'correct' programs (other than the fixed one) now parse.

As for incorrect programs...

test1, 2 cause an infinite loop 
(token() should automatically goto end or something if it gets FILE_END)

test3 does parse without infinite loops, but doesn't really resync properly.
About 20 errors, when there is really just one.

================================================================================
2/8 (TUES)

presentation - 3/8 
        Assembly / IR

Send him an email about ycombinator LLVM students guide



TODO: identifiers in symbol table

Combine +/- to adding_op class
Combine *// to mult_op class
Combine </>/<=/== to relation_op class
etc.


TODO
Remove TokenTypeStrings
Keep strings of tokens for debugging instead of printing token types


Only ever two scopes 
    - local and global 
    - proc decl / global decl 
    - proc inside a proc is not a nested scope; 
        only innermost proc decls and global decls matter


Array indices are of type int. Floats and ints should be separated by the lexer.
Maybe have a class NUMBER? sort of like adding_op
-done


Token will point to the symbol table for that token


Can only see declarations marked global or in the same scope (and only global variables defined before)

Error for redeclaration (define same identifier twice)

Don't keep string in token type for identifier

Flesh out symbol table in lexer (identifiers)


================================================================================
2/10 (SAT)

ISSUES:

according to spec, lower/upper_bound can't be negative; just a number
vecOps.src has a negative lower_bound
-Fixed in spec

Something is wrong with error handling; it's printing things weirdly


================================================================================
2/11 (SUN)

Value might be weird to be returning (in parser).

Maybe we should be returning a register? Once generating LLVM, it'll be resgister values, and the operations will not actually be happening in our code.

================================================================================
2/13 (MON)

Type checking

Declaration - fill symbol table
Symbol table entry:
    Identifer/Reserved word
    Global var/local var/proc
    Type of variable
    chain of pointers to other symbol tables for proc
        Lets us verify types of arguments match 
    Returning up from recursion - return a type?
    
LHS is valid LHS symbol (valid target) and its type matches RHS
"If" condition resolves to bool (or int -> bool)
Same for "for" conditions

Floats should convert to bool

What needs to be returned from parser functions?
    Type of return value (IDENTIFIER, INT, FLOAT, CHAR, STR, etc.)
    Value being returned (Once we're generating LLVM this 




Error handling:
    Illegal symbol - throw away and continue parsing
    

In var decl:
    if symbol.defined && ((symbol.global && tryingToDeclareGlobal) || (symbol.local && !tryingToDeclareGlobal))
        report err


TODO: Implement symbol table


Type conversion handling: promote all to float until it needs to be an int

