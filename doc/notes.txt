1/16 (TUES)

No need to combine operator types into one class, i.e. operator tokens become <operator, '+'>; causes problems later when parsing and checking precedence

dynamic dipatch?

Parts of speech 
Start, terminals, nonterninals, productions

Scanner only recognizes terminals; nonterminals are things like expressions, or sets of terminals

char classes - letter, number, symbol

Outside of main switch (not just in the default case or 0-9 cases:
    if letter - parse identifier or reserved word
    if number - parse num literal
    if symbol - go into char switch

Scanner - just get the next token - don't return all at once (other than for debug)

Go back in and make sure newlines always increment the line counter - carry along with the token so it can be identified at later stages. Also check for windows line endings (\r\n). Also \r should be in the whitespace category


================================================================================

1/18 (THURS)

Deterministic Finite Automata (DFA)


Dealing with scope:

Linked list of all symbols as they're added. When there's a new lexical level, place a marker on the chain indicating the new scope level. On the end of a scope, back up the chain (double linked list) until hitting the new scope level marker.

Declare multiple symbol tables; one for each scope


Lexer should throw an error when there's an illegal char; should not throw for comments
Error flags
Error reporting 


Digits can have underscores


Possibility - extend char classes; instead of [ch] -> token, have chars mapped to structs which have token type, isvalidchar, isvalidinstring, isvaliddigit


Presentation topics:

flex parser generator
LALR/bison parser generator
antlr LL(k)
JIT Translation
Garbage collection maybe?



Do LLVM rather than C



================================================================================

1/22 (MON)

Some questions

Is string a valid type_mark?
Seems to be referenced as a usable type in the language spec but it's not in the type_mark bnf


What is the default value of a newly declared var 
    (test1.src declares an integer but never sets it)
Should that integer be set to 0 initially?


================================================================================

1/23 (TUES)


Dynamic linking

backend is NPC
NPC (NP Complete)


-O flags in gcc (Error levels)
-Os should make program smaller
For my compiler, it adds 2k to the program size. Why?

Dynamic cast?


================================================================================

1/25 (THURS)


Student presentations:

Next Thurs
LLVM?

LLVM language

In memory format - Tie in to LLVM API for syntax tree 

LLVM Optimization

Flex - lexical analyzer generator (one student)




Intro to parsing

Sequence of tokens -> (abstract) syntax tree

Check the syntax (structure) of the program

Can't be specified with FSA or regex;
languages have non-regular constructs
    -Nesting
    -Recursion


BNF usually refers to EBNF (Extended BNF)

Syntax      - The sequence of tokens work together (parsing)
Semantics   - The types match and make sense (type checking)


Derivations
rightmost   - rightmost non-terminal is replaced at each step
leftmost    - leftmost ""

E =*> 3 + 8 - 2
E goes to the statement through derivations

Precedence in expressions is done with expr, term, factor 
    expr is composed of lowest precedence operators (+-) and terms
    terms are composed of higher precedence operators (*/) and factors
    factors - numbers/ids
Same parse tree under both leftmost/rightmost derivations



LLVM In-memory format



Symbol table in parser

main symbol table --- f1() symbol table --- f2() symbol table

while in f2, it checks f2 symbol table first but can check the ones up the stack as well



In scanner, simplify adding operators; the Token struct would be like: (TokenType::ADDING, specific token = + | -)


================================================================================

1/30 (TUES)

Parsing

Top down parsing


One pass compiler
Don't try to solve future problems yet, just do the parser.



