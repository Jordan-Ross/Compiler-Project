1/16 (TUES)

No need to combine operator types into one class, i.e. operator tokens become <operator, '+'>; causes problems later when parsing and checking precedence

dynamic dipatch?

Parts of speech 
Start, terminals, nonterninals, productions

Scanner only recognizes terminals; nonterminals are things like expressions, or sets of terminals

char classes - letter, number, symbol

Outside of main switch (not just in the default case or 0-9 cases:
    if letter - parse identifier or reserved word
    if number - parse num literal
    if symbol - go into char switch

Scanner - just get the next token - don't return all at once (other than for debug)

Go back in and make sure newlines always increment the line counter - carry along with the token so it can be identified at later stages. Also check for windows line endings (\r\n). Also \r should be in the whitespace category


================================================================================

1/18 (THURS)

Deterministic Finite Automata (DFA)


Dealing with scope:

Linked list of all symbols as they're added. When there's a new lexical level, place a marker on the chain indicating the new scope level. On the end of a scope, back up the chain (double linked list) until hitting the new scope level marker.

Declare multiple symbol tables; one for each scope


Lexer should throw an error when there's an illegal char; should not throw for comments
Error flags
Error reporting 


Digits can have underscores


Possibility - extend char classes; instead of [ch] -> token, have chars mapped to structs which have token type, isvalidchar, isvalidinstring, isvaliddigit


Presentation topics:

flex parser generator
LALR/bison parser generator
antlr LL(k)
JIT Translation
Garbage collection maybe?



Do LLVM rather than C



================================================================================

1/22 (MON)

Some questions

Is string a valid type_mark?
Seems to be referenced as a usable type in the language spec but it's not in the type_mark bnf


What is the default value of a newly declared var 
    (test1.src declares an integer but never sets it)
Should that integer be set to 0 initially?


================================================================================

1/23 (TUES)


Dynamic linking

backend is NPC
NPC (NP Complete)


-O flags in gcc (Error levels)
-Os should make program smaller
For my compiler, it adds 2k to the program size. Why?

Dynamic cast?


================================================================================

1/25 (THURS)


Student presentations:

Next Thurs
LLVM?

LLVM language

In memory format - Tie in to LLVM API for syntax tree 

LLVM Optimization

Flex - lexical analyzer generator (one student)




Intro to parsing

Sequence of tokens -> (abstract) syntax tree

Check the syntax (structure) of the program

Can't be specified with FSA or regex;
languages have non-regular constructs
    -Nesting
    -Recursion


BNF usually refers to EBNF (Extended BNF)

Syntax      - The sequence of tokens work together (parsing)
Semantics   - The types match and make sense (type checking)


Derivations
rightmost   - rightmost non-terminal is replaced at each step
leftmost    - leftmost ""

E =*> 3 + 8 - 2
E goes to the statement through derivations

Precedence in expressions is done with expr, term, factor 
    expr is composed of lowest precedence operators (+-) and terms
    terms are composed of higher precedence operators (*/) and factors
    factors - numbers/ids
Same parse tree under both leftmost/rightmost derivations



LLVM In-memory format



Symbol table in parser

main symbol table --- f1() symbol table --- f2() symbol table

while in f2, it checks f2 symbol table first but can check the ones up the stack as well



In scanner, simplify adding operators; the Token struct would be like: (TokenType::ADDING, specific token = + | -)


================================================================================

1/30 (TUES)

Parsing (Slides pt 2)

Top down parsing


One pass compiler (no intermediate form)
Don't try to solve future problems yet, just do the parser.


Need to recognize EOF


Parser should know what to expect next based on the structure of the language. 
e.g. 
IDENTIFIER := 
parser should expect an rvalue that can be assigned to an identifier, that is an expr or other valid rvalue

LL(1) - only look at single token
LL(k) - bad; grows exponentially


Top down parsers can only handle right recursive grammars
Our parser is left recursive, so we need a bottom up parser

Eliminate left recursion - left factoring

expr'() {
    token = scan()
    if token.tt == adding {
        token = scan()
        term()
        expr'()
    }
}

expr() {
    term()
    expr'()
}


Don't worry about errors yet


Given A -> a | b
a intersection b must be empty set
That is, a cannot contain the same symbols as b. 
First token of A must uniquely identify that it's type a or b.


empty string in FIRST(a) - first token of a



================================================================================

QUESTION:

When to get first token of a group? before entering that group or while in that group
e.g. when looking at program_body, a token is needed before entering declaration or statement 
    because it needs to check for program begin/end. 
    This means that while in statement/declaration, the first token of that block
    may already be consumed. 
    We can't put back and we can't peek tokens, so how do we deal with this?

Possible solution: assume that the group above on the call stack will 
    get the first token of the current group


What about optional things? 
    For a variable decl, there is optionally a [n] after for defining arrays.
    This may or may not be there, and there may just be a semicolon 
        or in|out|inout if it's a parameter. 
    But, the semicolon belongs in 

        <program_body> | <procedure_body> 
        
    and not <variable_declaration> or even <declaration>.

    If we let <variable_declaration> consume the semicolon, we need to:
        - Make sure all other declarations consume the optional semicolon
            - That is, <proc_declaration> has to consume one more token, even
                though that should always be a semicolon
        - Make sure every other usage of <variable_declaration> knows that it will
            consume an extra token 
            - That is, <parameter> needs to know that a call to 
                <variable_declaration> consumes the in|out|inout following it.




How exactly do in|out|inout work?


What is a declared variable set to by default?


